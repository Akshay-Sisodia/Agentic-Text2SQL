"""Database utility functions for query execution and schema management."""

import logging
import time
import asyncio
from typing import Any, Dict, List, Optional, Tuple, Union

from sqlalchemy import text
from sqlalchemy.exc import SQLAlchemyError

from app.core.database import get_engine
from app.schemas.response import QueryResult, QueryStatus
from app.schemas.sql import (ColumnInfo, DatabaseInfo, TableInfo,
                            SQLGenerationOutput, Relationship)

logger = logging.getLogger(__name__)


def execute_query(sql_query: str, params: Optional[Dict[str, Any]] = None, engine=None) -> QueryResult:
    """
    Execute a SQL query and return the results.
    
    Args:
        sql_query: SQL query string to execute
        params: Optional parameters for parameterized queries
        engine: Optional SQLAlchemy engine to use for the query
        
    Returns:
        QueryResult: Results of the query execution
    """
    if engine is None:
        engine = get_engine()
        
    start_time = time.time()
    
    result = QueryResult(status=QueryStatus.PENDING)
    result.rows = []
    
    try:
        with engine.connect() as connection:
            # Execute the query
            query = text(sql_query)
            execution_result = connection.execute(query, params or {})
            
            # Get column information - convert RMKeyView to a list of strings
            result.column_names = list(map(str, execution_result.keys()))
            
            # Create descriptive column information
            result.columns = [
                {
                    "name": str(col_name),
                    "type": str(execution_result.cursor.description[i][1]) if execution_result.cursor.description else "unknown",
                    "display_size": execution_result.cursor.description[i][2] if execution_result.cursor.description else None
                }
                for i, col_name in enumerate(result.column_names)
            ]
            
            # Fetch all rows (with reasonable limit)
            MAX_ROWS = 1000  # Limit to prevent memory issues
            result.rows = []
            
            # Convert SQLAlchemy row objects to dictionaries
            column_names = result.column_names
            for row in execution_result.fetchmany(MAX_ROWS):
                # Convert each row to a dictionary with column names as keys
                row_dict = {}
                for i, col_name in enumerate(column_names):
                    row_dict[col_name] = row[i]
                result.rows.append(row_dict)
                
            # Check if there are more rows
            result.has_more_rows = len(result.rows) == MAX_ROWS
            
            # Update row count (approximate for large results)
            result.row_count = len(result.rows)
            if result.has_more_rows:
                result.row_count = str(result.row_count) + "+"
                
            # Set status to success
            result.status = QueryStatus.SUCCESS
            
    except SQLAlchemyError as e:
        # Handle database errors
        result.status = QueryStatus.ERROR
        result.error_message = str(e)
        logger.error(f"Database error executing query: {str(e)}")
        
    except Exception as e:
        # Handle other errors
        result.status = QueryStatus.ERROR
        result.error_message = str(e)
        logger.error(f"Error executing query: {str(e)}")
        
    finally:
        # Record execution time
        result.execution_time = time.time() - start_time
        
    return result


def execute_generated_sql(sql: str, engine=None) -> QueryResult:
    """
    Execute SQL that was generated by the SQL agent.
    
    Args:
        sql: SQL query string or SQLGenerationOutput object
        engine: Optional SQLAlchemy engine to use for the query
        
    Returns:
        QueryResult: Results of the query execution
    """
    if isinstance(sql, SQLGenerationOutput):
        # If we received an object, extract the SQL string
        sql_query = sql.sql
    else:
        # Otherwise assume it's a string
        sql_query = sql
        
    # Execute the query
    return execute_query(sql_query, engine=engine)


def get_schema_info(engine=None) -> DatabaseInfo:
    """
    Get information about the database schema.
    
    Args:
        engine: SQLAlchemy engine (optional, will use global engine if None)
    
    Returns:
        DatabaseInfo: Information about the database schema
    """
    if engine is None:
        engine = get_engine()
        
    db_name = engine.url.database or "unknown"
    
    # Initialize database info
    db_info = DatabaseInfo(
        tables=[],
        name=db_name,
        vendor=engine.name,
        version=engine.driver,
    )
    
    try:
        with engine.connect() as connection:
            # Get table list (dialect-specific)
            if engine.name == 'sqlite':
                tables_query = """
                SELECT name FROM sqlite_master
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
                """
            elif engine.name == 'postgresql':
                tables_query = """
                SELECT table_name FROM information_schema.tables
                WHERE table_schema = 'public'
                """
            elif engine.name == 'mysql':
                tables_query = f"""
                SELECT table_name FROM information_schema.tables
                WHERE table_schema = '{db_name}'
                """
            elif engine.name == 'mssql':
                tables_query = """
                SELECT table_name FROM information_schema.tables
                WHERE table_schema = 'dbo'
                """
            elif engine.name == 'oracle':
                tables_query = """
                SELECT table_name FROM user_tables
                """
            else:
                # Generic fallback
                tables_query = """
                SELECT table_name FROM information_schema.tables
                WHERE table_schema NOT IN ('information_schema', 'pg_catalog', 'sys')
                """
            
            tables_result = connection.execute(text(tables_query))
            
            # Process each table
            for table_row in tables_result:
                table_name = table_row[0]
                
                # Create a new table entry
                table_info = TableInfo(
                    name=table_name,
                    description=f"Table {table_name}",
                    columns=[]
                )
                
                # Get column information (dialect-specific)
                if engine.name == 'sqlite':
                    # For SQLite, get column info from PRAGMA
                    columns_query = f"PRAGMA table_info({table_name})"
                    columns_result = connection.execute(text(columns_query))
                    
                    # Get unique constraints from SQLite index list
                    unique_columns = set()
                    try:
                        index_query = f"PRAGMA index_list({table_name})"
                        index_result = connection.execute(text(index_query))
                        
                        for index_row in index_result:
                            if index_row[2]:  # is_unique flag
                                index_name = index_row[1]
                                index_info_query = f"PRAGMA index_info({index_name})"
                                index_info_result = connection.execute(text(index_info_query))
                                
                                for index_info_row in index_info_result:
                                    unique_columns.add(index_info_row[2])  # column name
                    except Exception as e:
                        logger.warning(f"Error getting unique constraints for {table_name}: {str(e)}")
                    
                    for column_row in columns_result:
                        # SQLite PRAGMA returns: cid, name, type, notnull, dflt_value, pk
                        column_info = ColumnInfo(
                            name=column_row[1],  # name
                            data_type=column_row[2],  # type
                            nullable=not column_row[3],  # NOT notnull
                            primary_key=bool(column_row[5]),  # pk
                            unique=column_row[1] in unique_columns,  # set unique flag
                            description=f"Column {column_row[1]} of type {column_row[2]}"
                        )
                        table_info.columns.append(column_info)
                    
                    # Get foreign key information
                    foreign_keys_query = f"PRAGMA foreign_key_list({table_name})"
                    foreign_keys_result = connection.execute(text(foreign_keys_query))
                    
                    for fk_row in foreign_keys_result:
                        # Find the referenced column and update it
                        column_name = fk_row[3]  # from
                        ref_table = fk_row[2]    # table
                        ref_column = fk_row[4]   # to
                        
                        for col in table_info.columns:
                            if col.name == column_name:
                                col.foreign_key = f"{ref_table}.{ref_column}"
                                break
                
                elif engine.name in ['postgresql', 'mysql', 'mssql']:
                    # For other databases, use information_schema
                    columns_query = f"""
                    SELECT column_name, data_type, is_nullable, 
                           (CASE WHEN column_key = 'PRI' THEN 1 ELSE 0 END) as is_primary
                    FROM information_schema.columns
                    WHERE table_name = '{table_name}'
                    """
                    if engine.name == 'postgresql':
                        columns_query = f"""
                        SELECT column_name, data_type, is_nullable, 
                               (CASE WHEN column_name IN (
                                   SELECT column_name FROM information_schema.table_constraints tc
                                   JOIN information_schema.key_column_usage kcu 
                                   ON tc.constraint_name = kcu.constraint_name
                                   WHERE tc.constraint_type = 'PRIMARY KEY' 
                                   AND kcu.table_name = '{table_name}'
                               ) THEN 1 ELSE 0 END) as is_primary
                        FROM information_schema.columns
                        WHERE table_name = '{table_name}'
                        """
                        
                    columns_result = connection.execute(text(columns_query))
                    
                    for column_row in columns_result:
                        column_info = ColumnInfo(
                            name=column_row[0],  # column_name
                            data_type=column_row[1],  # data_type
                            nullable=column_row[2].lower() == 'yes',  # is_nullable
                            primary_key=bool(column_row[3]),  # is_primary
                            description=f"Column {column_row[0]} of type {column_row[1]}"
                        )
                        table_info.columns.append(column_info)
                    
                    # For PostgreSQL, get foreign key information
                    if engine.name == 'postgresql':
                        fk_query = f"""
                        SELECT kcu.column_name, ccu.table_name, ccu.column_name
                        FROM information_schema.table_constraints AS tc 
                        JOIN information_schema.key_column_usage AS kcu
                        ON tc.constraint_name = kcu.constraint_name
                        JOIN information_schema.constraint_column_usage AS ccu 
                        ON ccu.constraint_name = tc.constraint_name
                        WHERE tc.constraint_type = 'FOREIGN KEY' 
                        AND tc.table_name = '{table_name}'
                        """
                        fk_result = connection.execute(text(fk_query))
                        
                        for fk_row in fk_result:
                            column_name = fk_row[0]  # column_name
                            ref_table = fk_row[1]    # referenced table
                            ref_column = fk_row[2]   # referenced column
                            
                            for col in table_info.columns:
                                if col.name == column_name:
                                    col.foreign_key = f"{ref_table}.{ref_column}"
                                    break
                
                # Add this table to our list
                db_info.tables.append(table_info)
                
            # Add relationships based on foreign keys
            relationships = []
            for table in db_info.tables:
                for column in table.columns:
                    if column.foreign_key:
                        ref_table, ref_column = column.foreign_key.split(".")
                        
                        # Determine relationship type based on database constraints and cardinality
                        relationship_type = None
                        
                        # Find the target table
                        target_table = next((t for t in db_info.tables if t.name == ref_table), None)
                        
                        if target_table:
                            # Check if the referenced column is a primary key or unique in target table
                            target_column_obj = next((c for c in target_table.columns if c.name == ref_column), None)
                            source_is_unique = column.primary_key or column.unique
                            target_is_unique = target_column_obj and (target_column_obj.primary_key or target_column_obj.unique)
                            
                            # Determine relationship type based on uniqueness constraints
                            if source_is_unique and target_is_unique:
                                relationship_type = "ONE_TO_ONE"
                            elif source_is_unique and not target_is_unique:
                                relationship_type = "ONE_TO_MANY"
                            elif not source_is_unique and target_is_unique:
                                relationship_type = "MANY_TO_ONE"
                            else:
                                relationship_type = "MANY_TO_MANY"
                        
                        # Only add relationship if we determined a type
                        if relationship_type:
                            relationship = Relationship(
                                source_table=table.name,
                                source_column=column.name,
                                target_table=ref_table,
                                target_column=ref_column,
                                relationship_type=relationship_type
                            )
                            relationships.append(relationship)
            
            db_info.relationships = relationships
            
            return db_info
            
    except Exception as e:
        logger.error(f"Error getting schema info: {str(e)}")
        return db_info  # Return what we have so far


def get_table_info(connection, table_name: str, dialect: str, db_name: str = None) -> TableInfo:
    """
    Get information about a specific table.
    
    Args:
        connection: SQLAlchemy connection
        table_name: Name of the table
        dialect: Database dialect
        db_name: Database name (used for some dialects)
        
    Returns:
        TableInfo: Information about the table
    """
    # Initialize table info
    table_info = TableInfo(
        name=table_name,
        columns=[],
    )
    
    try:
        # Get column information (dialect-specific)
        if dialect == 'sqlite':
            columns_query = f"PRAGMA table_info('{table_name}')"
            columns_result = connection.execute(text(columns_query))
            
            for row in columns_result:
                col_info = ColumnInfo(
                    name=row[1],
                    data_type=row[2],
                    nullable=not bool(row[3]),
                    primary_key=bool(row[5]),
                )
                table_info.columns.append(col_info)
                
                if col_info.primary_key:
                    table_info.primary_keys.append(col_info.name)
            
            # Get foreign keys
            fk_query = f"PRAGMA foreign_key_list('{table_name}')"
            fk_result = connection.execute(text(fk_query))
            
            for row in fk_result:
                # Find the column
                for col in table_info.columns:
                    if col.name == row[3]:  # 'from' column
                        col.foreign_key = f"{row[2]}.{row[4]}"  # table.column
                        table_info.foreign_keys[col.name] = col.foreign_key
        
        elif dialect == 'postgresql':
            # Get column info
            columns_query = f"""
            SELECT 
                column_name, 
                data_type, 
                is_nullable, 
                column_default,
                (SELECT true FROM pg_constraint c
                 JOIN pg_attribute a ON a.attrelid = c.conrelid AND a.attnum = ANY(c.conkey)
                 WHERE c.contype = 'p' AND c.conrelid = '{table_name}'::regclass AND a.attname = column_name)
                 as is_primary
            FROM information_schema.columns
            WHERE table_name = '{table_name}' AND table_schema = 'public'
            """
            columns_result = connection.execute(text(columns_query))
            
            for row in columns_result:
                col_info = ColumnInfo(
                    name=row[0],
                    data_type=row[1],
                    nullable=row[2].upper() == 'YES',
                    primary_key=bool(row[3]),
                )
                table_info.columns.append(col_info)
                
                if col_info.primary_key:
                    table_info.primary_keys.append(col_info.name)
            
            # Get foreign keys
            fk_query = f"""
            SELECT
                kcu.column_name,
                ccu.table_name AS foreign_table_name,
                ccu.column_name AS foreign_column_name
            FROM
                information_schema.table_constraints AS tc
                JOIN information_schema.key_column_usage AS kcu
                    ON tc.constraint_name = kcu.constraint_name
                    AND tc.table_schema = kcu.table_schema
                JOIN information_schema.constraint_column_usage AS ccu
                    ON ccu.constraint_name = tc.constraint_name
            WHERE tc.constraint_type = 'FOREIGN KEY'
                AND tc.table_name = '{table_name}'
                AND tc.table_schema = 'public'
            """
            fk_result = connection.execute(text(fk_query))
            
            for row in fk_result:
                col_name, foreign_table, foreign_column = row[0], row[1], row[2]
                for col in table_info.columns:
                    if col.name == col_name:
                        col.foreign_key = f"{foreign_table}.{foreign_column}"
                        table_info.foreign_keys[col.name] = col.foreign_key
                        
        elif dialect == 'mysql':
            # Get column info
            columns_query = f"""
            SELECT 
                column_name, 
                data_type, 
                is_nullable, 
                column_default,
                column_key
            FROM information_schema.columns
            WHERE table_name = '{table_name}' AND table_schema = '{db_name}'
            """
            columns_result = connection.execute(text(columns_query))
            
            for row in columns_result:
                col_info = ColumnInfo(
                    name=row[0],
                    data_type=row[1],
                    nullable=row[2].upper() == 'YES',
                    primary_key=row[4] == 'PRI' if row[4] else False,
                )
                table_info.columns.append(col_info)
                
                if col_info.primary_key:
                    table_info.primary_keys.append(col_info.name)
            
            # Get foreign keys
            fk_query = f"""
            SELECT
                column_name,
                referenced_table_name,
                referenced_column_name
            FROM information_schema.key_column_usage
            WHERE table_name = '{table_name}'
                AND table_schema = '{db_name}'
                AND referenced_table_name IS NOT NULL
            """
            fk_result = connection.execute(text(fk_query))
            
            for row in fk_result:
                col_name, foreign_table, foreign_column = row[0], row[1], row[2]
                for col in table_info.columns:
                    if col.name == col_name:
                        col.foreign_key = f"{foreign_table}.{foreign_column}"
                        table_info.foreign_keys[col.name] = col.foreign_key
        
        elif dialect == 'mssql':
            # Get column info
            columns_query = f"""
            SELECT 
                c.name as column_name,
                t.name as data_type,
                c.is_nullable,
                CASE WHEN pk.column_id IS NOT NULL THEN 1 ELSE 0 END as is_primary_key
            FROM sys.columns c
            JOIN sys.types t ON c.user_type_id = t.user_type_id
            LEFT JOIN (
                SELECT ic.column_id, ic.object_id
                FROM sys.index_columns ic
                JOIN sys.indexes i ON ic.object_id = i.object_id AND ic.index_id = i.index_id
                JOIN sys.key_constraints kc ON i.object_id = kc.parent_object_id AND i.index_id = kc.unique_index_id
                WHERE kc.type = 'PK'
            ) pk ON c.column_id = pk.column_id AND c.object_id = pk.object_id
            WHERE c.object_id = OBJECT_ID('{table_name}')
            """
            columns_result = connection.execute(text(columns_query))
            
            for row in columns_result:
                col_info = ColumnInfo(
                    name=row[0],
                    data_type=row[1],
                    nullable=bool(row[2]),
                    primary_key=bool(row[3]),
                )
                table_info.columns.append(col_info)
                
                if col_info.primary_key:
                    table_info.primary_keys.append(col_info.name)
            
            # Get foreign keys
            fk_query = f"""
            SELECT 
                COL_NAME(fc.parent_object_id, fc.parent_column_id) AS column_name,
                OBJECT_NAME(f.referenced_object_id) AS foreign_table,
                COL_NAME(fc.referenced_object_id, fc.referenced_column_id) AS foreign_column
            FROM sys.foreign_keys AS f
            INNER JOIN sys.foreign_key_columns AS fc ON f.OBJECT_ID = fc.constraint_object_id
            WHERE OBJECT_NAME(f.parent_object_id) = '{table_name}'
            """
            fk_result = connection.execute(text(fk_query))
            
            for row in fk_result:
                col_name, foreign_table, foreign_column = row[0], row[1], row[2]
                for col in table_info.columns:
                    if col.name == col_name:
                        col.foreign_key = f"{foreign_table}.{foreign_column}"
                        table_info.foreign_keys[col.name] = col.foreign_key
                        
        elif dialect == 'oracle':
            # Get column info
            columns_query = f"""
            SELECT 
                column_name,
                data_type,
                nullable,
                CASE WHEN constraint_type = 'P' THEN 1 ELSE 0 END as is_primary
            FROM (
                SELECT
                    c.column_name,
                    c.data_type,
                    DECODE(c.nullable, 'Y', 1, 0) as nullable,
                    pk.constraint_type
                FROM user_tab_columns c
                LEFT JOIN (
                    SELECT cols.column_name, cons.constraint_type
                    FROM user_cons_columns cols
                    JOIN user_constraints cons ON cols.constraint_name = cons.constraint_name
                    WHERE cons.constraint_type = 'P' AND cons.table_name = '{table_name}'
                ) pk ON c.column_name = pk.column_name
                WHERE c.table_name = '{table_name}'
            )
            """
            columns_result = connection.execute(text(columns_query))
            
            for row in columns_result:
                col_info = ColumnInfo(
                    name=row[0],
                    data_type=row[1],
                    nullable=bool(row[2]),
                    primary_key=bool(row[3]),
                )
                table_info.columns.append(col_info)
                
                if col_info.primary_key:
                    table_info.primary_keys.append(col_info.name)
            
            # Get foreign keys
            fk_query = f"""
            SELECT 
                a.column_name,
                c_pk.table_name as foreign_table,
                b_pk.column_name as foreign_column
            FROM user_cons_columns a
            JOIN user_constraints c ON a.constraint_name = c.constraint_name
            JOIN user_constraints c_pk ON c.r_constraint_name = c_pk.constraint_name
            JOIN user_cons_columns b_pk ON c_pk.constraint_name = b_pk.constraint_name
            WHERE c.constraint_type = 'R'
              AND a.table_name = '{table_name}'
            """
            fk_result = connection.execute(text(fk_query))
            
            for row in fk_result:
                col_name, foreign_table, foreign_column = row[0], row[1], row[2]
                for col in table_info.columns:
                    if col.name == col_name:
                        col.foreign_key = f"{foreign_table}.{foreign_column}"
                        table_info.foreign_keys[col.name] = col.foreign_key
        
        else:
            # Generic approach for other databases (simplified)
            columns_query = f"""
            SELECT column_name, data_type, is_nullable, 
                   column_default, column_key, extra
            FROM information_schema.columns
            WHERE table_name = '{table_name}'
            """
            columns_result = connection.execute(text(columns_query))
            
            for row in columns_result:
                col_info = ColumnInfo(
                    name=row[0],
                    data_type=row[1],
                    nullable=row[2].upper() == 'YES',
                    primary_key=row[4] == 'PRI' if row[4] else False,
                )
                table_info.columns.append(col_info)
                
                if col_info.primary_key:
                    table_info.primary_keys.append(col_info.name)
        
        # Get row count (approximate)
        try:
            count_query = f"SELECT COUNT(*) FROM {table_name}"
            count_result = connection.execute(text(count_query))
            table_info.row_count = count_result.scalar()
        except Exception as e:
            logger.warning(f"Could not get row count for {table_name}: {str(e)}")
            table_info.row_count = 0
        
        # Get sample values for each column (limit to 5)
        for col in table_info.columns:
            try:
                if dialect == 'oracle':
                    sample_query = f"SELECT DISTINCT {col.name} FROM {table_name} WHERE ROWNUM <= 5"
                elif dialect == 'mssql':
                    sample_query = f"SELECT DISTINCT TOP 5 {col.name} FROM {table_name}"
                else:
                    sample_query = f"SELECT DISTINCT {col.name} FROM {table_name} LIMIT 5"
                    
                sample_result = connection.execute(text(sample_query))
                col.sample_values = [str(row[0]) for row in sample_result if row[0] is not None]
            except Exception:
                # Skip sample values if there's an error
                pass
    
    except Exception as e:
        logger.error(f"Error getting table info for {table_name}: {str(e)}")
    
    return table_info


async def get_sqlite_schema(db_path: str) -> DatabaseInfo:
    """
    Get schema information for a SQLite database.
    
    Args:
        db_path: Path to the SQLite database file
        
    Returns:
        DatabaseInfo: Database schema information
    """
    # Use the synchronous get_schema_info in an async wrapper
    # This could be refactored later for true async operation
    loop = asyncio.get_event_loop()
    
    # Use the existing get_schema_info function
    # We're running it in an executor because it's synchronous
    # and contains potentially blocking I/O operations
    db_info = await loop.run_in_executor(None, get_schema_info)
    
    # Add relationships based on foreign keys
    relationships = []
    for table in db_info.tables:
        for column in table.columns:
            if column.foreign_key:
                # Foreign key format is "table.column"
                parts = column.foreign_key.split('.')
                if len(parts) == 2:
                    target_table_name, target_column_name = parts
                    
                    # Determine relationship type based on database constraints and cardinality
                    relationship_type = None
                    
                    # Find the target table
                    target_table = next((t for t in db_info.tables if t.name == target_table_name), None)
                    
                    if target_table:
                        # Check if the referenced column is a primary key or unique in target table
                        target_column_obj = next((c for c in target_table.columns if c.name == target_column_name), None)
                        source_is_unique = column.primary_key or column.unique
                        target_is_unique = target_column_obj and (target_column_obj.primary_key or target_column_obj.unique)
                        
                        # Determine relationship type based on uniqueness constraints
                        if source_is_unique and target_is_unique:
                            relationship_type = "ONE_TO_ONE"
                        elif source_is_unique and not target_is_unique:
                            relationship_type = "ONE_TO_MANY"
                        elif not source_is_unique and target_is_unique:
                            relationship_type = "MANY_TO_ONE"
                        else:
                            relationship_type = "MANY_TO_MANY"
                    
                    # Only add relationship if we determined a type
                    if relationship_type:
                        relationship = Relationship(
                            source_table=table.name,
                            source_column=column.name,
                            target_table=target_table_name,
                            target_column=target_column_name,
                            relationship_type=relationship_type
                        )
                        relationships.append(relationship)
    
    # Add relationships to database info
    db_info.relationships = relationships
    
    # Add description if missing
    if not db_info.description:
        db_info.description = f"SQLite database at {db_path}"
    
    return db_info 